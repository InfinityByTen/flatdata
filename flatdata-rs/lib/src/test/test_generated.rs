// Do not edit: This code was generated by flatdata's generator.
pub mod test {

pub mod schema {
pub mod structs {
pub const A: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

"#;
pub const B: &str = r#"namespace test {
struct B
{
    id : u32 : 16;
}
}

"#;
pub const R: &str = r#"namespace test {
struct R
{
    @range( x )
    first_x : u32 : 16;
    y : u32 : 16;
}
}

"#;}pub mod s {
pub const S: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive S
{
    data : .test.A;
}
}

"#;
pub mod resources {pub const DATA: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive S
{
    data : .test.A;
}
}

"#;}
}
pub mod x {
pub const X: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
}
}

"#;
pub mod resources {pub const DATA: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
}
}

"#;}
}
pub mod y {
pub const Y: &str = r#"namespace test {
struct R
{
    @range( x )
    first_x : u32 : 16;
    y : u32 : 16;
}
}

namespace test {
archive Y
{
    data : vector< .test.R >;
}
}

"#;
pub mod resources {pub const DATA: &str = r#"namespace test {
struct R
{
    @range( x )
    first_x : u32 : 16;
    y : u32 : 16;
}
}

namespace test {
archive Y
{
    data : vector< .test.R >;
}
}

"#;}
}
pub mod z {
pub const Z: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
struct B
{
    id : u32 : 16;
}
}

namespace test {
archive Z
{
    ab : multivector< 16, .test.A, .test.B >;
}
}

"#;
pub mod resources {pub const AB: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
struct B
{
    id : u32 : 16;
}
}

namespace test {
archive Z
{
    ab : multivector< 16, .test.A, .test.B >;
}
}

"#;}
}
pub mod w {
pub const W: &str = r#"namespace test {
archive W
{
    blob : raw_data;
}
}

"#;
pub mod resources {pub const BLOB: &str = r#"namespace test {
archive W
{
    blob : raw_data;
}
}

"#;}
}
}
#[derive(Clone, Debug)]
pub struct A {}

#[derive(Clone, Copy)]
pub struct ARef<'a> {
    data: *const u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> crate::Struct<'a> for A
{
    const SCHEMA: &'static str = schema::structs::A;
    const SIZE_IN_BYTES: usize = 6;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;

    type Item = ARef<'a>;

    #[inline]
    fn create(data : &'a[u8]) -> Self::Item
    {
        Self::Item{ data : data.as_ptr(), _phantom : std::marker::PhantomData }
    }

    type ItemMut = AMut<'a>;

    #[inline]
    fn create_mut(data: &'a mut[u8]) -> Self::ItemMut
    {
        Self::ItemMut{ data : data.as_mut_ptr(), _phantom : std::marker::PhantomData }
    }
}

impl crate::NoOverlap for A {}

impl<'a> ARef<'a> {
    #[inline]
    pub fn x(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }    #[inline]
    pub fn y(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 16, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }    #[inline]
    pub fn e(&self) -> super::test::E {
        let value = flatdata_read_bytes!(u32, self.data, 32, 16);
        unsafe { std::mem::transmute::<u32, super::test::E>(value) }
    }
    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for ARef<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("A")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("e", &self.e())
            .finish()
    }
}

impl<'a> std::cmp::PartialEq for ARef<'a> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.x() == other.x() &&        self.y() == other.y() &&        self.e() == other.e()     }
}

impl<'a> crate::Ref for ARef<'a> {}

pub struct AMut<'a> {
    data: *mut u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> AMut<'a> {
    #[inline]
    pub fn x(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn set_x(&mut self, value: u32) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 6)
        };
        flatdata_write_bytes!(u32; value, buffer, 0, 16)
    }

    #[inline]
    pub fn y(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 16, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn set_y(&mut self, value: u32) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 6)
        };
        flatdata_write_bytes!(u32; value, buffer, 16, 16)
    }

    #[inline]
    pub fn e(&self) -> super::test::E {
        let value = flatdata_read_bytes!(u32, self.data, 32, 16);
        unsafe { std::mem::transmute::<u32, super::test::E>(value) }
    }

    #[inline]
    pub fn set_e(&mut self, value: super::test::E) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 6)
        };
        flatdata_write_bytes!(u32; value, buffer, 32, 16)
    }


    #[inline]
    pub fn fill_from(&mut self, other: &ARef) {
        self.set_x(other.x());
        self.set_y(other.y());
        self.set_e(other.e());
    }

    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }

    #[inline]
    pub fn as_mut_ptr(&self) -> *mut u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for AMut<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        ARef { data : self.data, _phantom : std::marker::PhantomData }.fmt( f )
    }
}

impl<'a> crate::RefMut for AMut<'a> {}

#[derive(Clone, Debug)]
pub struct B {}

#[derive(Clone, Copy)]
pub struct BRef<'a> {
    data: *const u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> crate::Struct<'a> for B
{
    const SCHEMA: &'static str = schema::structs::B;
    const SIZE_IN_BYTES: usize = 2;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;

    type Item = BRef<'a>;

    #[inline]
    fn create(data : &'a[u8]) -> Self::Item
    {
        Self::Item{ data : data.as_ptr(), _phantom : std::marker::PhantomData }
    }

    type ItemMut = BMut<'a>;

    #[inline]
    fn create_mut(data: &'a mut[u8]) -> Self::ItemMut
    {
        Self::ItemMut{ data : data.as_mut_ptr(), _phantom : std::marker::PhantomData }
    }
}

impl crate::NoOverlap for B {}

impl<'a> BRef<'a> {
    #[inline]
    pub fn id(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }
    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for BRef<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("B")
            .field("id", &self.id())
            .finish()
    }
}

impl<'a> std::cmp::PartialEq for BRef<'a> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()     }
}

impl<'a> crate::Ref for BRef<'a> {}

pub struct BMut<'a> {
    data: *mut u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> BMut<'a> {
    #[inline]
    pub fn id(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn set_id(&mut self, value: u32) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 2)
        };
        flatdata_write_bytes!(u32; value, buffer, 0, 16)
    }


    #[inline]
    pub fn fill_from(&mut self, other: &BRef) {
        self.set_id(other.id());
    }

    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }

    #[inline]
    pub fn as_mut_ptr(&self) -> *mut u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for BMut<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        BRef { data : self.data, _phantom : std::marker::PhantomData }.fmt( f )
    }
}

impl<'a> crate::RefMut for BMut<'a> {}

#[derive(Clone, Debug)]
pub struct R {}

#[derive(Clone, Copy)]
pub struct RRef<'a> {
    data: *const u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> crate::Struct<'a> for R
{
    const SCHEMA: &'static str = schema::structs::R;
    const SIZE_IN_BYTES: usize = 4;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;

    type Item = RRef<'a>;

    #[inline]
    fn create(data : &'a[u8]) -> Self::Item
    {
        Self::Item{ data : data.as_ptr(), _phantom : std::marker::PhantomData }
    }

    type ItemMut = RMut<'a>;

    #[inline]
    fn create_mut(data: &'a mut[u8]) -> Self::ItemMut
    {
        Self::ItemMut{ data : data.as_mut_ptr(), _phantom : std::marker::PhantomData }
    }
}


impl<'a> RRef<'a> {
    #[inline]
    pub fn first_x(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }#[inline]
    pub fn x(&self) -> std::ops::Range<u32> {
        let start = flatdata_read_bytes!(u32, self.data, 0, 16);
        let end = flatdata_read_bytes!(u32, self.data, 0 + 4 * 8, 16);
        start..end
    }

    #[inline]
    pub fn y(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 16, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }
    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for RRef<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("R")
            .field("first_x", &self.first_x())
            .field("y", &self.y())
            .finish()
    }
}

impl<'a> std::cmp::PartialEq for RRef<'a> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.first_x() == other.first_x() &&        self.y() == other.y()     }
}

impl<'a> crate::Ref for RRef<'a> {}

pub struct RMut<'a> {
    data: *mut u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> RMut<'a> {
    #[inline]
    pub fn first_x(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 0, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn set_first_x(&mut self, value: u32) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 4)
        };
        flatdata_write_bytes!(u32; value, buffer, 0, 16)
    }

    #[inline]
    pub fn y(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data, 16, 16);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn set_y(&mut self, value: u32) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 4)
        };
        flatdata_write_bytes!(u32; value, buffer, 16, 16)
    }


    #[inline]
    pub fn fill_from(&mut self, other: &RRef) {
        self.set_first_x(other.first_x());
        self.set_y(other.y());
    }

    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }

    #[inline]
    pub fn as_mut_ptr(&self) -> *mut u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for RMut<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        RRef { data : self.data, _phantom : std::marker::PhantomData }.fmt( f )
    }
}

impl<'a> crate::RefMut for RMut<'a> {}

#[derive(Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum E {
    Value = 0,
}

impl crate::helper::Int for E {
    const IS_SIGNED: bool = false;
}




#[derive(Clone)]
pub struct S {
    _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    data: crate::MemoryDescriptor,
}

impl S {
    fn read_resource(
        storage: &dyn crate::ResourceStorage,
        name: &str,
        schema: &str,
    ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError>
    {
        storage.read(name, schema).map(|x| crate::MemoryDescriptor::new(&x))
    }

    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn data(&self) -> <super::test::A as crate::Struct>::Item
    {
        <super::test::A as crate::Struct>::create(&unsafe {self.data.as_bytes()})
    }

}

impl ::std::fmt::Debug for S {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("S")
            .field("data", &self.data())
            .finish()
    }
}

impl crate::Archive for S {
    const NAME: &'static str = "S";
    const SCHEMA: &'static str = schema::s::S;

    fn open(storage: ::std::rc::Rc<dyn crate::ResourceStorage>)
        -> ::std::result::Result<Self, crate::ResourceStorageError>
    {
        storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

        let data = Self::read_resource(&*storage, "data", schema::s::resources::DATA)?;

        Ok(Self {
            _storage: storage,
            data,
        })
    }
}

#[derive(Clone, Debug)]
pub struct SBuilder {
    storage: ::std::rc::Rc<dyn crate::ResourceStorage>
}

impl SBuilder {
    #[inline]
    pub fn set_data(&self, resource: <super::test::A as crate::Struct>::Item) -> ::std::io::Result<()> {
        let data = unsafe {
            ::std::slice::from_raw_parts(resource.as_ptr(), <super::test::A as crate::Struct>::SIZE_IN_BYTES)
        };
        self.storage.write("data", schema::s::resources::DATA, data)
    }

}

impl crate::ArchiveBuilder for SBuilder {
    const NAME: &'static str = "S";
    const SCHEMA: &'static str = schema::s::S;

    fn new(
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ) -> Result<Self, crate::ResourceStorageError> {
        crate::create_archive::<Self>(&storage)?;
        Ok(Self { storage })
    }
}






#[derive(Clone)]
pub struct X {
    _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    data: crate::MemoryDescriptor,
}

impl X {
    fn read_resource(
        storage: &dyn crate::ResourceStorage,
        name: &str,
        schema: &str,
    ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError>
    {
        storage.read(name, schema).map(|x| crate::MemoryDescriptor::new(&x))
    }

    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn data(&self) -> crate::ArrayView<super::test::A>
    {
        crate::ArrayView::new(&unsafe {self.data.as_bytes()})
    }

}

impl ::std::fmt::Debug for X {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("X")
            .field("data", &self.data())
            .finish()
    }
}

impl crate::Archive for X {
    const NAME: &'static str = "X";
    const SCHEMA: &'static str = schema::x::X;

    fn open(storage: ::std::rc::Rc<dyn crate::ResourceStorage>)
        -> ::std::result::Result<Self, crate::ResourceStorageError>
    {
        storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

        let data = Self::read_resource(&*storage, "data", schema::x::resources::DATA)?;

        Ok(Self {
            _storage: storage,
            data,
        })
    }
}

#[derive(Clone, Debug)]
pub struct XBuilder {
    storage: ::std::rc::Rc<dyn crate::ResourceStorage>
}

impl XBuilder {
    #[inline]
    pub fn set_data(&self, vector: &crate::ArrayView<super::test::A>) -> ::std::io::Result<()> {
        self.storage.write("data", schema::x::resources::DATA, vector.as_ref())
    }

    #[inline]
    pub fn start_data(&self) -> ::std::io::Result<crate::ExternalVector<super::test::A>> {
        crate::create_external_vector(&*self.storage, "data", schema::x::resources::DATA)
    }

}

impl crate::ArchiveBuilder for XBuilder {
    const NAME: &'static str = "X";
    const SCHEMA: &'static str = schema::x::X;

    fn new(
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ) -> Result<Self, crate::ResourceStorageError> {
        crate::create_archive::<Self>(&storage)?;
        Ok(Self { storage })
    }
}






#[derive(Clone)]
pub struct Y {
    _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    data: crate::MemoryDescriptor,
}

impl Y {
    fn read_resource(
        storage: &dyn crate::ResourceStorage,
        name: &str,
        schema: &str,
    ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError>
    {
        storage.read(name, schema).map(|x| crate::MemoryDescriptor::new(&x))
    }

    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn data(&self) -> crate::ArrayView<super::test::R>
    {
        crate::ArrayView::new(&unsafe {self.data.as_bytes()})
    }

}

impl ::std::fmt::Debug for Y {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("Y")
            .field("data", &self.data())
            .finish()
    }
}

impl crate::Archive for Y {
    const NAME: &'static str = "Y";
    const SCHEMA: &'static str = schema::y::Y;

    fn open(storage: ::std::rc::Rc<dyn crate::ResourceStorage>)
        -> ::std::result::Result<Self, crate::ResourceStorageError>
    {
        storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

        let data = Self::read_resource(&*storage, "data", schema::y::resources::DATA)?;

        Ok(Self {
            _storage: storage,
            data,
        })
    }
}

#[derive(Clone, Debug)]
pub struct YBuilder {
    storage: ::std::rc::Rc<dyn crate::ResourceStorage>
}

impl YBuilder {
    #[inline]
    pub fn set_data(&self, vector: &crate::ArrayView<super::test::R>) -> ::std::io::Result<()> {
        self.storage.write("data", schema::y::resources::DATA, vector.as_ref())
    }

    #[inline]
    pub fn start_data(&self) -> ::std::io::Result<crate::ExternalVector<super::test::R>> {
        crate::create_external_vector(&*self.storage, "data", schema::y::resources::DATA)
    }

}

impl crate::ArchiveBuilder for YBuilder {
    const NAME: &'static str = "Y";
    const SCHEMA: &'static str = schema::y::Y;

    fn new(
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ) -> Result<Self, crate::ResourceStorageError> {
        crate::create_archive::<Self>(&storage)?;
        Ok(Self { storage })
    }
}





/// Builtin union type of .test.A, .test.B.
#[derive(Clone, PartialEq)]
pub enum AbRef<'a> {
    A(<super::test::A as crate::Struct<'a>>::Item),    B(<super::test::B as crate::Struct<'a>>::Item),}

impl<'a> ::std::fmt::Debug for AbRef<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AbRef::A(ref inner) => write!(f, "{:?}", inner),
            AbRef::B(ref inner) => write!(f, "{:?}", inner),
        }
    }
}

impl<'a> crate::VariadicRef for AbRef<'a> {
    #[inline]
    fn size_in_bytes(&self) -> usize {
        match *self {
            AbRef::A(_) => <super::test::A as crate::Struct<'a>>::SIZE_IN_BYTES,
            AbRef::B(_) => <super::test::B as crate::Struct<'a>>::SIZE_IN_BYTES,
        }
    }
}

pub struct AbBuilder<'a> {
    data: &'a mut Vec<u8>
}

impl<'a> AbBuilder<'a> {
    #[inline]
    pub fn add_a<'b>(&'b mut self) -> <super::test::A as crate::Struct<'b>>::ItemMut {
        let old_len = self.data.len();
        let increment = 1 + <super::test::A as crate::Struct<'b>>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len - crate::PADDING_SIZE] = 0;
        <super::test::A as crate::Struct<'b>>::create_mut(
            &mut self.data[1 + old_len - crate::PADDING_SIZE..]
        )
    }
    #[inline]
    pub fn add_b<'b>(&'b mut self) -> <super::test::B as crate::Struct<'b>>::ItemMut {
        let old_len = self.data.len();
        let increment = 1 + <super::test::B as crate::Struct<'b>>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len - crate::PADDING_SIZE] = 1;
        <super::test::B as crate::Struct<'b>>::create_mut(
            &mut self.data[1 + old_len - crate::PADDING_SIZE..]
        )
    }
}

#[derive(Clone)]
pub struct Ab {}

impl<'a> crate::VariadicStruct<'a> for Ab {
    type Index = super::_builtin::multivector::IndexType16;

    type Item = AbRef<'a>;

    #[inline]
    fn create(index: crate::TypeIndex, data: &'a [u8]) -> Self::Item
    {
        match index {
                0 => AbRef::A(<super::test::A as crate::Struct<'a>>::create(data)),
                1 => AbRef::B(<super::test::B as crate::Struct<'a>>::create(data)),
            _ => panic!("invalid type index {} for variadic type AbRef", index),
        }
    }

    type ItemMut = AbBuilder<'a>;

    #[inline]
    fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut
    {
        Self::ItemMut { data }
    }
}

#[derive(Clone)]
pub struct Z {
    _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ab: (crate::MemoryDescriptor, crate::MemoryDescriptor),
}

impl Z {
    fn read_resource(
        storage: &dyn crate::ResourceStorage,
        name: &str,
        schema: &str,
    ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError>
    {
        storage.read(name, schema).map(|x| crate::MemoryDescriptor::new(&x))
    }

    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn ab(&self) -> crate::MultiArrayView<Ab>
    {
        crate::MultiArrayView::new(
            crate::ArrayView::new(&unsafe {self.ab.0.as_bytes()}),
            &unsafe {self.ab.1.as_bytes()},
        )
    }

}

impl ::std::fmt::Debug for Z {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("Z")
            .field("ab", &self.ab())
            .finish()
    }
}

impl crate::Archive for Z {
    const NAME: &'static str = "Z";
    const SCHEMA: &'static str = schema::z::Z;

    fn open(storage: ::std::rc::Rc<dyn crate::ResourceStorage>)
        -> ::std::result::Result<Self, crate::ResourceStorageError>
    {
        storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

        let ab = {
            let index_schema = &format!("index({})", schema::z::resources::AB);
            let index = Self::read_resource(&*storage, "ab_index", &index_schema)?;
            let data = Self::read_resource(&*storage, "ab", schema::z::resources::AB)?;            (index, data)
        };

        Ok(Self {
            _storage: storage,
            ab,
        })
    }
}

#[derive(Clone, Debug)]
pub struct ZBuilder {
    storage: ::std::rc::Rc<dyn crate::ResourceStorage>
}

impl ZBuilder {
    #[inline]
    pub fn start_ab(&self) -> ::std::io::Result<crate::MultiVector<Ab>> {
        crate::create_multi_vector(&*self.storage, "ab", schema::z::resources::AB)
    }

}

impl crate::ArchiveBuilder for ZBuilder {
    const NAME: &'static str = "Z";
    const SCHEMA: &'static str = schema::z::Z;

    fn new(
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ) -> Result<Self, crate::ResourceStorageError> {
        crate::create_archive::<Self>(&storage)?;
        Ok(Self { storage })
    }
}






#[derive(Clone)]
pub struct W {
    _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    blob: crate::MemoryDescriptor,
}

impl W {
    fn read_resource(
        storage: &dyn crate::ResourceStorage,
        name: &str,
        schema: &str,
    ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError>
    {
        storage.read(name, schema).map(|x| crate::MemoryDescriptor::new(&x))
    }

    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn blob(&self) -> crate::RawData {
        crate::RawData::new(unsafe {self.blob.as_bytes()})
    }

}

impl ::std::fmt::Debug for W {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("W")
            .field("blob", &self.blob())
            .finish()
    }
}

impl crate::Archive for W {
    const NAME: &'static str = "W";
    const SCHEMA: &'static str = schema::w::W;

    fn open(storage: ::std::rc::Rc<dyn crate::ResourceStorage>)
        -> ::std::result::Result<Self, crate::ResourceStorageError>
    {
        storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

        let blob = Self::read_resource(&*storage, "blob", schema::w::resources::BLOB)?;

        Ok(Self {
            _storage: storage,
            blob,
        })
    }
}

#[derive(Clone, Debug)]
pub struct WBuilder {
    storage: ::std::rc::Rc<dyn crate::ResourceStorage>
}

impl WBuilder {
    #[inline]
    pub fn set_blob(&self, data: &[u8]) -> ::std::io::Result<()> {
        self.storage.write("blob", schema::w::resources::BLOB, data)
    }

}

impl crate::ArchiveBuilder for WBuilder {
    const NAME: &'static str = "W";
    const SCHEMA: &'static str = schema::w::W;

    fn new(
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    ) -> Result<Self, crate::ResourceStorageError> {
        crate::create_archive::<Self>(&storage)?;
        Ok(Self { storage })
    }
}


}

pub mod _builtin {

pub mod multivector {

pub mod schema {
pub mod structs {
pub const INDEX_TYPE16: &str = r#""#;}}
#[derive(Clone, Debug)]
pub struct IndexType16 {}

#[derive(Clone, Copy)]
pub struct IndexType16Ref<'a> {
    data: *const u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> crate::Struct<'a> for IndexType16
{
    const SCHEMA: &'static str = schema::structs::INDEX_TYPE16;
    const SIZE_IN_BYTES: usize = 2;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;

    type Item = IndexType16Ref<'a>;

    #[inline]
    fn create(data : &'a[u8]) -> Self::Item
    {
        Self::Item{ data : data.as_ptr(), _phantom : std::marker::PhantomData }
    }

    type ItemMut = IndexType16Mut<'a>;

    #[inline]
    fn create_mut(data: &'a mut[u8]) -> Self::ItemMut
    {
        Self::ItemMut{ data : data.as_mut_ptr(), _phantom : std::marker::PhantomData }
    }
}


impl<'a> IndexType16Ref<'a> {
    #[inline]
    pub fn value(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data, 0, 16);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }#[inline]
    pub fn range(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data, 0, 16);
        let end = flatdata_read_bytes!(u64, self.data, 0 + 2 * 8, 16);
        start..end
    }


    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for IndexType16Ref<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("IndexType16")
            .field("value", &self.value())
            .finish()
    }
}

impl<'a> std::cmp::PartialEq for IndexType16Ref<'a> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()     }
}

impl<'a> crate::Ref for IndexType16Ref<'a> {}

pub struct IndexType16Mut<'a> {
    data: *mut u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> IndexType16Mut<'a> {
    #[inline]
    pub fn value(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data, 0, 16);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    #[inline]
    pub fn set_value(&mut self, value: u64) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, 2)
        };
        flatdata_write_bytes!(u64; value, buffer, 0, 16)
    }


    #[inline]
    pub fn fill_from(&mut self, other: &IndexType16Ref) {
        self.set_value(other.value());
    }

    #[inline]
    pub fn as_ptr(&self) -> *const u8 {
        self.data
    }

    #[inline]
    pub fn as_mut_ptr(&self) -> *mut u8 {
        self.data
    }
}

impl<'a> std::fmt::Debug for IndexType16Mut<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        IndexType16Ref { data : self.data, _phantom : std::marker::PhantomData }.fmt( f )
    }
}

impl<'a> crate::RefMut for IndexType16Mut<'a> {}

impl<'a> crate::IndexStruct<'a> for IndexType16 {
    #[inline]
    fn range(data: Self::Item) -> std::ops::Range<usize> {
        let range = data.range();
        range.start as usize..range.end as usize
    }

    #[inline]
    fn set_index(mut data: Self::ItemMut, value: usize) {
        data.set_value(value as u64);
    }
}

}

pub mod schema {
pub mod structs {}}
}
