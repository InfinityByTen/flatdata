{%- macro declaration(struct) %}

{% if struct.doc %}
{{ struct.doc | rust_doc }}
{% endif %}
///
/// ## Access pattern
///
/// This structure is used as a template parameter in containers.
/// It does not contain any data, instead it references
///
/// * [`{{struct.name}}Ref`] for the read-only access, and
/// * [`{{struct.name}}Mut`] for the mutable access
///
/// to the `{{struct.name}}` data.
///
/// [`{{struct.name}}Ref`]: struct.{{struct.name}}Ref.html
/// [`{{struct.name}}Mut`]: struct.{{struct.name}}Mut.html
#[derive(Clone, Debug)]
pub struct {{struct.name}} {}

/// Read-only access to [`{{struct.name}}`].
///
/// [`{{struct.name}}`]: struct.{{struct.name}}.html
#[derive(Clone, Copy)]
pub struct {{struct.name}}Ref<'a> {
    data: *const u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> flatdata::Struct<'a> for {{ struct.name }}
{
    const SCHEMA: &'static str = schema::structs::{{ struct.name | camel_to_snake_case | upper }};
    const SIZE_IN_BYTES: usize = {{ struct.size_in_bytes }};
    const IS_OVERLAPPING_WITH_NEXT : bool = {% if struct | has_range %}true{%else%}false{%endif%};

    type Item = {{ struct.name }}Ref<'a>;

    #[inline]
    fn create(data : &'a[u8]) -> Self::Item
    {
        Self::Item { data : data.as_ptr(), _phantom : std::marker::PhantomData }
    }

    type ItemMut = {{ struct.name }}Mut<'a>;

    #[inline]
    fn create_mut(data: &'a mut[u8]) -> Self::ItemMut
    {
        Self::ItemMut { data : data.as_mut_ptr(), _phantom : std::marker::PhantomData }
    }
}

{% if not struct | has_range %}
impl flatdata::NoOverlap for {{struct.name}} {}
{% endif %}

impl<'a> {{ struct.name }}Ref<'a> {
    {% for field in struct.fields %}
    {% if field.doc and not field.range %}
    {{ field.doc | rust_doc }}
    {% elif field.range %}
    /// First element of the range [`{{ field.range | escape_rust_keywords }}`].
    ///
    /// [`{{ field.range | escape_rust_keywords }}`]: #method.{{ field.range | escape_rust_keywords }}
    {% endif %}
    #[inline]
    pub fn {{ field.name | escape_rust_keywords }}(&self) -> {{ field | field_type }} {
        let value = flatdata_read_bytes!({{ field | primitive_type }}, self.data, {{ field.offset }}, {{ field.type.width }});
        unsafe { std::mem::transmute::<{{ field | primitive_type }}, {{ field | field_type }}>(value) }
    }

    {%- if field.range -%}
    {% if field.doc %}
    {{ field.doc | rust_doc }}
    {% endif %}
    #[inline]
    pub fn {{ field.range | escape_rust_keywords }}(&self) -> std::ops::Range<{{ field | field_type }}> {
        let start = flatdata_read_bytes!({{ field.type.name }}, self.data, {{ field.offset }}, {{ field.type.width }});
        let end = flatdata_read_bytes!({{ field.type.name }}, self.data, {{ field.offset }} + {{ struct.size_in_bytes }} * 8, {{ field.type.width }});
        start..end
    }

    {% endif %}
    {% endfor %}
}

impl<'a> std::fmt::Debug for {{ struct.name }}Ref<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("{{ struct.name }}")
            {% for field in struct.fields %}
            {% set name = field.name | escape_rust_keywords %}
            .field("{{ name }}", &self.{{ name }}())
            {% endfor %}
            .finish()
    }
}

impl<'a> std::cmp::PartialEq for {{ struct.name }}Ref<'a> {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        {% for field in struct.fields %}
        {% set name = field.name | escape_rust_keywords %}
        self.{{ name }}() == other.{{ name }}() {% if not loop.last %}&&{% endif %}
        {% endfor %}
    }
}

impl<'a> flatdata::Ref for {{ struct.name }}Ref<'a> {}

/// Mutable access to [`{{struct.name}}`].
///
/// [`{{struct.name}}`]: struct.{{struct.name}}.html
pub struct {{ struct.name }}Mut<'a> {
    data: *mut u8,
    _phantom: std::marker::PhantomData<&'a u8>,
}

impl<'a> {{ struct.name }}Mut<'a> {
    {% for field in struct.fields %}
    {% set name = field.name | escape_rust_keywords %}
    {% if field.doc and not field.range %}
    {{ field.doc | rust_doc }}
    {% elif field.range %}
    /// First element of the range [`{{ field.range | escape_rust_keywords }}`].
    ///
    /// [`{{ field.range | escape_rust_keywords }}`]: struct.{{ struct.name }}Ref.html#method.{{ field.range | escape_rust_keywords }}
    {% endif %}
    #[inline]
    pub fn {{ name }}(&self) -> {{ field | field_type }} {
        let value = flatdata_read_bytes!({{ field | primitive_type }}, self.data, {{ field.offset }}, {{ field.type.width }});
        unsafe { std::mem::transmute::<{{ field | primitive_type }}, {{ field | field_type }}>(value) }
    }

    #[inline]
    pub fn set_{{ name }}(&mut self, value: {{ field | field_type }}) {
        let buffer = unsafe {
            std::slice::from_raw_parts_mut(self.data, {{ struct.size_in_bytes }})
        };
        flatdata_write_bytes!({{ field | primitive_type }}; value, buffer, {{ field.offset }}, {{ field.type.width }})
    }

    {% endfor %}

    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &{{ struct.name }}Ref) {
        {% for field in struct.fields %}
        {% set name = field.name | escape_rust_keywords %}
        self.set_{{ name }}(other.{{ name }}());
        {% endfor %}
    }
}

impl<'a> std::fmt::Debug for {{ struct.name }}Mut<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        {{ struct.name }}Ref { data : self.data, _phantom : std::marker::PhantomData }.fmt( f )
    }
}

impl<'a> flatdata::RefMut for {{ struct.name }}Mut<'a> {}

{%- endmacro %}
